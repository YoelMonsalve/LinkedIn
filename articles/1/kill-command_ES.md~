<!-- title: The Linux kill command -->
<!-- author: Yoel Monsalve -->
# El comando `kill` en Linux

## Escrito por: _Yoel Monsalve_
_Esta es la versión en español del artículo intitulado "The kill command"_

_Una gu'ia comprensible del comando `kill`, para desmitificar cosas extra~nas dichas en el mundo de la programaci'on._

>Hace alg'un tiempo, escuch'e alguien decir que "el comando `kill` es para matar un proceso". Bueno, eso no es t'ecnicamente correcto. Estrictamente hablando, el comando `kill` es para _enviar una se~nal a un proceso_. Esto es un error frecuente que he escuchado de programadores novatos, o la gente que s'olo toca los temas superficialmente. Pero, vamos a la ayuda/documentaci'on  de Linux:

```bash
$ kill --help

kill: kill [-s sigspec | -n signum | -sigspec] pid | jobspec ... or kill -l [sigspec]
```
```
    Send a signal to a job.
     
    Send the processes identified by PID or JOBSPEC the signal named by
    SIGSPEC or SIGNUM.  If neither SIGSPEC nor SIGNUM is present, then
    SIGTERM is assumed.
    
    Options:
      -s sig	SIG is a signal name
      -n sig	SIG is a signal number
      -l	list the signal names; if arguments follow `-l' they are
    		assumed to be signal numbers for which names should be listed
      -L	synonym for -l
    
    Kill is a shell builtin for two reasons: it allows job IDs to be used
    instead of process IDs, and allows processes to be killed if the limit
    on processes that you can create is reached.
    
    Exit Status:
    Returns success unless an invalid option is given or an error occurs.

```

As'i que la respuesta es muy clara: 'Terminar/matar' un proceso es solo una de las muchas cosas que se pueden hacer a trav'es de este comando. Las "se~nales" (`signals`) son un tema fascinante, y el lector interesado puede consultar este [manpage](https://man7.org/linux/man-pages/man2/signal.2.html), o este art'iculo de [_computerhope_&nbsp;](https://www.computerhope.com/unix/signals.htm), entre otros.

Se~nalar (`signaling`), es un mecanismo t'ipico para comunicaci'on entre procesos. Se env'ia una se~nal a un proceso, esperando que dicho proceso realice una acci'on espec'ifica. Estas acciones pueden ser, por ejemplo, pausar/retomar el proceso (`SIGSTOP`, `SIGCONT`), o terminar el proceso [bien sea de forma amigable o no-amigable](`SIGTERM`,`SIGKILL`). Otros comportamientos en respuesta a una se~nal son menos conocidos, por ejemplo que un proceso padre sea consciente de la terminaci'on de uno de sus hijos (`SIGCHILD`), o para pedir a un proceso que ejecute una acci'on predeterminada solicitada por el usuario (`SIGUSR1`). Usted puede ver la lista completa del comportamiento estándar ante las se~nales más comunes, en el art'iculo de [_computerhope_&nbsp;](https://www.computerhope.com/unix/signals.htm).

Vale la pena se~nalar que las _se~nales_ son un mecanismo crucial en cualquier sistema bien dise~nado, para trabajar con una arquitectura de multi-proceso.

Para ver una lista completa de todas las se~nales disponibles en su sistema, tipee

```bash
$ kill -l

 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP
 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1
11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM
16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP
21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ
26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR
31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3
38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8
43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13
48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12
53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7
58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2
63) SIGRTMAX-1	64) SIGRTMAX	
```

La sintaxis para enviar una se~al determinada a un proceso, digamos la se~nal para pedir una terminaci'on amigable `SIGTERM`, es:

```bash
$ kill -s SIGTERM <pid>
```

done `<pid` es el ID de proceso, un entero 'unico que sirve como identificador de dicho proceso. Cada proceso tiene un ID que es automáticamente asignado por el sistema operativo (y no se puede/debe cambiar). Hay algunos comandos que pueden ser 'utiles para averiguar el PID de un programa, como
[`pgrep`](https://www.man7.org/linux/man-pages/man1/pgrep.1.html), o
[`ps`](https://www.man7.org/linux/man-pages/man1/ps.1.html). Sin embargo, esto ser'ia suficiente material para un art'iculo completo, y no será cubierto aqu'i.

Otras formas para la sintaxis del comando `kill` son:

```bash
$ kill -s TERM <pid>
```
y (un especie de manera abreviada de lo anterior):

```bash
$ kill -TERM <pid>
```

o, usando el _numero_ de se~nal en lugar del nem'onico para la misma (**NO recomendado**, ya que los numeros de se~nal podrian hipot'eticamente variar en un futuro, o variar entre un sistema u otro):

```bash
$ kill -n 15 <pid>
```

```bash
$ kill 15 <pid>
```

## Un primer experimento

Sup'ongase que se tiene un proceso _perezoso_ ("_lazy_") el cual no hace más que "dormir" por un tiempo (cuando se dice "dormir", se está refiriendo a la acci'on _sleep_ del ingl'es que significa que dicho proceso se coloca en un estado de hibernaci'on o pausado, mientras otro proceso pasa al estado de actividad en su lugar). Ejemplo:

```python
"""FILE: lazy.py
"""
from time import sleep
import os

print('I\'m a very lazy process -.). Please, don\'t disturb ...')
print(f'My PID = {os.getpid()}')
sleep(10)
print('Lazy program says ... Bye !\n')
```

Lo interesante es que una vez nuestro proceso perezoso está durmiendo y secuestra la consola, nosotros podemos simplemente pausarlo (pero no terminarlo) mediante la combinaci'on de teclas `CTRL + Z` (en sistemas UNIX). Una vez hecho esto, el proceso es detenido:

```bash
$ python lazy.py 
I'm a very lazy process -.). Please, don't disturb ...
My PID = 76750
^Z
[1]+  Stopped                 python lazy.py
```
Observe que el programa está imprimiendo su propio PID, de modo que facilitar al usuario conocer este ID, y enviarle alguna se~nal si es necesario.

Ahora, una vez que tenemos de nuevo tiempo para dedicarle a nuestro proceso perezoso, vamos a reactivarlo enviándole la se~nal  `SIGCONT` (continue):

```bash
$ kill -CONT 76750
$ Lazy program says ... Bye !

```

Luego de retomar el proceso, este termina su ciclo de espera y luego de ello imprime un mensaje de despedida y termina.

Este proceso de detenci'on de procesos puede ser usado, por ejemplo, para tomar
'capturas' a programas que dirigen su salida a la consola (y de este modo observar el flujo de actividades del proceso, imprimir valores de variables, etc). Es realmente un mecanismo muy 'util, aunque rudimentario, de hacer _debugging_ de programas.

## Empezando a familiarizarse con _jobs_ (tareas)

Trabajar en terminales de sistema UNIX puede volverse productivo cuando empezamos a usar los _jobs_, o tareas. Un _job_ es un proceso corriendo bajo una terminal. Posiblemente usted not'o el mensaje particular

```bash
^Z
[1]+  Stopped                 python lazy.py
```

cuando detuvimos el programa perezoso. Esto significa que la terminal a cargo está identificando dicho proceso con el _job number_ (n'umero de tarea) igual a 1 (esto podr'ia ser un n'umero mayor si usted tiene varias tareas corriendo en la misma terminal).

De acuerdo a la ayuda del comando `kill`, es tambi'en posible usar la sintaxis:

```bash
kill [-s sigspec | -n signum | -sigspec] jobspec 
```

donde `jobspec` es la identificaci'on para la tarea objetivo (que se debe pasar incluyendo el carácter '%' delante del n'umero). Es decir:

```bash
$ python lazy.py 
I'm a very lazy process -.). Please, don't disturb ...
My PID = 77330
^Z                               <-- you press CTRL + Z
[1]+  Stopped                 python lazy.py

$ kill -CONT %1                  <-- this will resume process
$ Lazy program says ... Bye !    <-- process is done
```

## La forma fácil.

Si usted solo está interesado en detener/continuar un proceso, puede profundizar un poco más en el concepto de los _jobs_. Presionar `CTRL + Z` pausa la tarea y la pone en segundo plano o _background_. Podemos luego reactivar el proceso pausar, tray'endolo de vuelta al primer plano o  _foreground_. 

| ESTADO | SIGNIFICADO |
| --- | --- |
background | el proceso pasa a estado pausado
foreground | el proceso está despierto y activo para interactuar con el teclado

Podemos mover un proceso al segundo plano (`background`), y luego al primero  (`foreground`) usando, respectivamente, los comandos `fg` y `bg`. Ejemplo

```bash
fg %1    .... pone el job ID=1 en estado background (stop)
bg %1    .... pone el job ID=1 en estado foreground (resume)
```

Usted puede alternar un proceso entre el segundo plano y el primer plano tantas veces como quiera, mientras el proceso est'e a'un vivo y siendo manejado por dicha terminal.

Presionar `CTRL + Z` env'ia impl'iciamente una se~nal `STOP` a un proceso, de modo que este es de hecho puesto en estado background. Para restaurarlo, use `fg`. Puede moverlo de nuevo al background con `bg`, luego de nuevo al foreground con `fg`, ... etc.

```bash
$ python lazy.py 
I'm a very lazy process -.). Please, don't disturb ...
My PID = 77771
^Z                               <-- you press CTRL + Z
[1]+  Stopped                 python lazy.py
$ fg %1                          <-- this will resume child, until its completion
python lazy.py
Lazy program says ... Bye !
```

Note que la orden `fg` env'ia impl'icitamente una se~nal `CONT` al proceso hijo , de modo que usar `fg`/`bg` es prácticamente equivalente al uso "manual" de comandos `kill -STOP|-CONT`.

## Explorando otras opciones

Quizá usted decidi'o que ya tuvo suficiente de este proceso perezoso, y quiere simplemente terminarlo. Entonces, usted debe despachar la se~nal `TERM` para terminar de una vez con esta molestia: 

```bash
$ python lazy.py 
I'm a very lazy process -.). Please, don't disturb ...
My PID = 77907
^Z                               <-- you press CTRL + Z
[1]+  Stopped                 python lazy.py
$ kill -TERM %1                  <-- kill the annoying bug

[1]+  Stopped                 python lazy.py
$                                <-- press ENTER again, and you will see
[1]+  Terminated              python lazy.py
                                 (the annoying thing is gone!)
```

OK, esto puede lucir un poco extra~no. Una vez que se ha enviado la se~nal de terminaci'on, la consola responde diciendo que el proceso estaba en estado de pausa. Presione ENTER de nuevo y la terminal informará que el hijo ha sido terminado.
Este es s'olo uno de esos "comportamientos `UNIX`" (y que puede ser modificando al configurar algunas variables shell, pero no profundizaremos en ello ahora.)

Una nota final: La se~nal `TERM` env'ia una solicitud de terminaci'on amigable al proceso objetivo. Este se supone que ejecuta algunos procedimientos "on-close" antes de su terminaci'on, como cerrar descriptores de fichero abiertos, propagar la se~nal a sus procesos hijos, y otros. Existe tambi'en la otra se~nal más ruda llamada `KILL` que no puede ser ignorada por el proceso, y su efecto es terminar el proceso objetivo inmediatamente, e incondicionalmente. Pero, sea consciente y emplee cosas como esta:

```bash
$ kill -KILL <pid>|<jobspec>
```

solo como 'ultimo recurso. Lo ideal es primero enviar la se~nal amigable `TERM`, luego despu'es de algunos segundos intentar `TERM` nuevamente, y despu'es de algunos intentos más infructuosos, entonces enviar la se~nal ruda `KILL`.

_Y, esto es todo por ahora. Deseando que haya disfrutado este material y esperando compartir más art'iculos pronto !_ 
